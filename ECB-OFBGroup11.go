package main

import "fmt"

/* an array with 4 rows and 2 columns*/
var codebook = [4][2]int{{0b00, 0b01}, {0b01, 0b10}, {0b10, 0b11}, {0b11, 0b00}}
// The codebook is a 2D array with 4 rows and 2 columns, where each row represents a binary value and its corresponding ciphered value.

var message = [4]int{0b00, 0b01, 0b10, 0b11}
// The message is an array of 4 binary values.

var iv int = 0b10
// The initialization vector (iv) is a binary value.

func codebookLookup(xor int) (lookupValue int) {
    // This function takes an XOR value and returns the corresponding ciphered value from the codebook.
    var i, j int = 0, 0
    for i = 0; i < 4; i++ {
        if codebook[i][j] == xor {
            j++
            lookupValue = codebook[i][j]
            break
        }
    }
    return lookupValue
}

func main() {
    // ECB encryption
    fmt.Println("ECB encryption details:")
    fmt.Printf("Plaintext: %b\n", message)
    // The plaintext message is printed.
    ciphertext := make([]int, len(message))
    // A new array called ciphertext is created to store the ciphered values.
    for i := 0; i < len(message); i++ {
        ciphertext[i] = codebookLookup(message[i])
        // Each binary value in the message is encrypted by looking up its corresponding ciphered value in the codebook.
        fmt.Printf("The ciphered value of %b is %b\n", message[i], ciphertext[i])
        // The plaintext and ciphered values are printed.
    }

    // OFB encryption
    fmt.Println("\nOFB encryption details:")
    fmt.Printf("Plaintext: %b\n", message)
    // The plaintext message is printed.
    stream := iv
    // The stream cipher is generated from the initialization vector (iv).
    ciphertext = make([]int, len(message))
    // A new array called ciphertext is created to store the ciphered values.
    for i := 0; i < len(message); i++ {
        xor := message[i] ^ stream
        // The XOR value is generated by XORing the binary value in the message with the stream cipher.
        ciphertext[i] = codebookLookup(xor)
        // The XOR value is looked up in the codebook to get the ciphered value.
        stream = ciphertext[i]
        // The ciphered value is used to update the stream cipher for the next iteration.
        fmt.Printf("The ciphered value of %b is %b\n", message[i], ciphertext[i])
        // The plaintext and ciphered values are printed.
    }
}
